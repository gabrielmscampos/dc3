import traceback
from importlib import util as importlib_util

from django.conf import settings
from jwcrypto.jws import InvalidJWSSignature
from jwcrypto.jwt import JWTExpired, JWTNotYetValid
from rest_framework.authentication import BaseAuthentication
from rest_framework.request import Request

from .backends import CERNKeycloakOIDC
from .exceptions import AuthenticationFailed
from .token import CERNKeycloakToken
from .user import CERNKeycloakUser


if importlib_util.find_spec("drf_spectacular"):
    try:
        from .schemes import *  # noqa: F401,F403
    except ImportError:
        pass

public_kc = CERNKeycloakOIDC(
    server_url=settings.KEYCLOAK_SERVER_URL,
    client_id=settings.KEYCLOAK_PUBLIC_CLIENT_ID,
    realm_name=settings.KEYCLOAK_REALM,
)

confidential_kc = CERNKeycloakOIDC(
    server_url=settings.KEYCLOAK_SERVER_URL,
    client_id=settings.KEYCLOAK_CONFIDENTIAL_CLIENT_ID,
    client_secret_key=settings.KEYCLOAK_CONFIDENTIAL_SECRET_KEY,
    realm_name=settings.KEYCLOAK_REALM,
)


class CERNKeycloakBearerAuthentication(BaseAuthentication):
    """
    Custom authentication class based on CERN's Keycloak Bearer Token.

    This authentication flow must be configured using the argument `expected_bearer_token_type`.
    For the public client, it only checks the public aud and azp.
    For the confidential client, it checks only for the confidential aud and for both public and confidential azp.

    What is the use case?
        * Public tokens **should only** authenticate **in a specific token exchange route**
        in order to receive a confidential token
        * Confidential tokens can authenticate in any other route
        but we need to make sure that the token was generated by the confidential client
        or exchanged from the public client

    Note: Confidential tokens are generated from the confidential client
    if someone uses a script for the general token endpoint
    and interactively sign-on via the totp (password) flow or device flow
    """

    HEADER_KEY = "Authorization"
    PUBLIC_TOKEN_TYPE = "public"  # noqa: S105
    CONFIDENTIAL_TOKEN_TYPE = "confidential"  # noqa: S105

    def authenticate(self, request: Request) -> tuple[CERNKeycloakUser, CERNKeycloakToken] | None:
        access_token = self.get_access_token(request.headers)
        kc, valid_aud, valid_azp = self.get_kc_by_expected_token()
        token = CERNKeycloakToken(access_token, kc)

        try:
            token.validate(valid_aud, valid_azp)
        except InvalidJWSSignature as err:
            raise AuthenticationFailed(
                "Found and invalid jws signature while decoding the access token.", "access_token_invalid_jws_signature"
            ) from err
        except JWTExpired as err:
            raise AuthenticationFailed("Access token has expired.", "access_token_expired") from err
        except JWTNotYetValid as err:
            raise AuthenticationFailed("Access token not yet valid.", "access_token_not_yet_valid") from err
        except Exception as err:  # noqa: BLE001
            print(traceback.format_exc())
            raise AuthenticationFailed("Unexpected error validating token.", "access_token_unexpected_error") from err

        return CERNKeycloakUser(token), token

    def get_kc_by_expected_token(self):
        if self.expected_bearer_token_type == self.PUBLIC_TOKEN_TYPE:
            valid_aud = [settings.KEYCLOAK_PUBLIC_CLIENT_ID]
            valid_azp = [settings.KEYCLOAK_PUBLIC_CLIENT_ID]
            kc = public_kc
        elif self.expected_bearer_token_type == self.CONFIDENTIAL_TOKEN_TYPE:
            valid_aud = [settings.KEYCLOAK_CONFIDENTIAL_CLIENT_ID]
            valid_azp = [
                settings.KEYCLOAK_CONFIDENTIAL_CLIENT_ID,
                settings.KEYCLOAK_PUBLIC_CLIENT_ID,
            ]
            kc = confidential_kc
        else:
            raise ValueError("expected_bearer_token_type should only be public or confidential.")

        return kc, valid_aud, valid_azp

    def get_access_token(self, headers: dict) -> str:
        try:
            bearer = headers[self.HEADER_KEY]
        except KeyError as err:
            raise AuthenticationFailed("Authorization header not found.", "authorization_not_found") from err

        try:
            return bearer.split("Bearer ")[-1]
        except AttributeError as err:
            raise AuthenticationFailed("Malformed access token.", "bad_access_token") from err


class CERNKeycloakPublicAuthentication(CERNKeycloakBearerAuthentication):
    """
    Custom authentication class based on `CERNKeycloakBearerAuthentication` that
    will only authenticate tokens generated by the public client.
    """

    def __init__(self):
        super().__init__()
        self.expected_bearer_token_type = self.PUBLIC_TOKEN_TYPE


class CERNKeycloakConfidentialAuthentication(CERNKeycloakBearerAuthentication):
    """
    Custom authentication class based on `CERNKeycloakBearerAuthentication` that
    will only authenticate tokens generated by the confidential client or
    generated by the public client and later exchanged with the confidential client.
    """

    def __init__(self):
        super().__init__()
        self.expected_bearer_token_type = self.CONFIDENTIAL_TOKEN_TYPE
